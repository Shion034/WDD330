<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Almendra:wght@700&family=M+PLUS+Rounded+1c:wght@300&family=Ubuntu:ital,wght@0,400;1,700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../CSS/stylesheet.css">


    <title>Portfolio</title>

</head>


<body>

    <header>
        <h1 class="headtitle"> <a href="../index.html">WDD 330 Portfolio</a></h1>
        <h3>SHION KEATY</h3>
    </header>

    <main>
        <h2>Week 07</h2>

        <section>
        <h4>●Notes●</h4>
            
            <h5>Further Function</h5>
                    <p>
                        <strong>Function Properties and Methods</strong><br>
                        <strong>Call and Apply Methods</strong><br>
                        <strong>Custom Properties</strong><br>
                        There is nothing to stop you adding your own properties to functions in the same way that you can add properties to any
                        object in JavaScript. For example, you could add a description property to a function that describes what it does.<br>
                        <strong>Memoization</strong><br>
                        A useful feature of this is that it provides result caching, or memoization.
                        If a function takes some time to compute a return value, we can save the result in a cache property. Then if the same
                        argument is used again later, we can return the value from the cache, rather than having to compute the result again.<br>
                        <strong>Immediately Invoked Function Expressions</strong><br>
                        An Immediately Invoked Function Expression – or IIFE – (pronounced 'iffy') is an anonymous function that, as the name
                        suggests, is invoked as soon as it’s defined.<br>
                        <strong>Temporary Variables</strong><br>
                        <strong>Initialization Code</strong><br>
                        <strong>Safe Use of Strict Mode</strong><br>
                        <strong>Creating Self-contained Code Blocks</strong><br>
                        <strong>Functions that Define and Rewrite Themselves</strong><br>
                        The dynamic nature of JavaScript means that a function is able to not only call itself, but define itself, and even
                        redefine itself. This is done by assigning an anonymous function to a variable that has the same name as the function.<br>
                        <strong>Init-Time Branching</strong><br>
                        <strong>Recursive Functions</strong><br>
                        A recursive function is one that invokes itself until a certain condition is met. It’s a useful tool to use when
                        iterative processes are involved. A common example is a function that calculates the factorial of a number:<br>
                        <strong>Callbacks</strong><br>
                        You’ll recall that they’re functions passed to other functions as arguments and then invoked inside the function they
                        are passed to.<br> 
                        <strong>Event-driven Asynchronous Programming</strong><br>
                        Callbacks can be used to facilitate event-driven asynchronous programming. JavaScript is a single-threaded environment,
                        which means only one piece of code will ever be processed at a time. This may seem like a limitation, but non-blocking
                        techniques can be used to ensure that the program continues to run.<br>
                        <strong>Callback Hell</strong><br>
                        <strong>Promises</strong><br>
                        A promise represents the future result of an asynchronous operation. Promises don't do anything that can't already be
                        achieved using callbacks, but they help simplify the process, and avoid the convoluted code that can result from using
                        multiple callbacks.<br>
                        <I>The Promise Life Cycle</I><br>
                        When a promise is created, it calls an asynchronous operation and is then said to be pending. It remains in this state
                        while the operation is taking place. At this stage, the promise is said to be unsettled. Once the operation has
                        completed, the promise is said to have been settled. A settled promise can result in two different outcomes:<br>
                        Resolved ― the asynchronous operation was completed successfully.<br>
                        Rejected ― the asynchronous operation didn’t work as expected, wasn't successfully completed or resulted in an error.<br>
                        <I>A Super Promise</I><br>
                        <I>Creating A Promise</I><br>
                        <I>Dealing With A Settled Promise</I><br>
                        <I>Chaining Multiple Promises</I><br>
                        <I>Async Functions</I><br>
                        <I>Generalized Functions</I><br>
                        <I>Functions That Return Functions</I><br>
                        <strong>Closures</strong><br>
                        Closures are one of JavaScript’s most powerful features, but they can be difficult to get your head around initially.<br>
                        <strong>Function Scope</strong><br>
                        <strong>Returning Functions</strong><br>
                        Functions declared from within another function have access to any variables declared in the outer function’s scope.
                        A closure is formed when the inner function is returned by the outer function, maintaining access to any variables
                        declared inside the enclosing function.<br>
                        <strong>Functional Programming</strong><br>
                        Functional programming is a programming paradigm. Other examples of programming paradigms include object oriented
                        programming and procedural programming. JavaScript is a multi-paradigm language, meaning that it can be used to program
                        in a variety of paradigms (and sometimes a mash-up of them!). This flexibility is an attractive feature of the language,
                        but it also makes it harder to adopt a particular coding style as the principles are not enforced by the language.<br>
                        <strong>Pure Functions</strong><br>
                        <strong>Higher-Order Functions</strong><br>
                        Higher-order functions are functions that accept another function as an argument, or return another function as a
                        result, or both.Closures are used extensively in higher-order functions as they allow us to create a generic function that can be used
                        to then return more specific functions based on its arguments. This is done by creating a closure around a function's
                        arguments that keeps them 'alive' in a return function.
                           
                    </p>
                <h5>Ajax</h5>
                <p>
                    Ajax is a technique that allows web pages to communicate asynchronously with a server, and it dynamically updates web
                    pages without reloading. This enables data to be sent and received in the background, as well as portions of a page to
                    be updated in response to user events, while the rest of the program continues to run.<br>
                    <strong>Clients and Servers</strong><br>
                    The web of computers known as the internet can be separated into two parts: clients and servers. A client, such as a web
                    browser, will request a resource (usually a web page) from a server, which processes the request and sends back a
                    response to the client.<br>
                    JavaScript was originally designed as a client-side scripting language, meaning that it ran locally in the browser,
                    adding dynamic features to the web page that was returned from the server. Ajax allows JavaScript to request resources
                    from a server on behalf of the client.<br>
                    <strong>A Brief History of Ajax</strong><br>
                    <i>Asynchronous</i><br>
                    When a request for data is sent, the program doesn’t have to stop and wait for the response. It can carry on running,
                    waiting for an event to fire when a response is received.<br>
                    <i>JavaScript</i><br>
                    JavaScript was always considered a 'front-end' language, not used to communicate with the server.<br>
                    <i>XML</i><br>
                    <strong>The Fetch API</strong><br>
                    <strong>Basic Usage</strong><br>
                    The Fetch API provides a global fetch() method that only has one mandatory argument, which is the URL of the resource
                    you wish to fetch.<br>
                    <strong>Response Interface</strong><br>
                    The Fetch API introduced the Response interface that deals with the object that’s returned when the promise is
                    fulfilled.Response objects have a number of properties and methods that allow us to process the response effectively.
                    <strong>Headers Interface</strong><br>
                    HTTP headers are used to pass on any additional information about a request or response. Typical information contained
                    in headers includes the file-type of the resource, cookie information, authentication information and when the resource
                    was last modified.<br>
                    <strong>Sending Information</strong><br>
                    We can also use Ajax to send information. This can be a variety of formats, but is usually a JSON string.<br>
                    <strong>A Living Standard</strong><br>
                    The Fetch API is, at the time of writing, what is known as a 'living standard', which means that the specification is
                    being developed 'in the wild'. This means that, despite it being available to use, it’s still subject to change as
                    developers, browser vendors and end-users provide feedback about how it works. It’s an experimental technology, and new
                    features might get added, or the syntax and behavior of some properties and methods might change in the future.













                </p>
                    <div id="exercises">
                    <h5>Exercises</h5>
                    <h5><span><a href="../week7/ajax.html">Receiving Information</a></span></h5>
                    <h5><span><a href="../week7/todo.html">Todo API</a></span></h5>
                    <!--<h5>JavaScript 30 : <span><a href="../JavaScript30/Day05/index.html">Day05</a></span></h5>
                    <h5>JavaScript 30 : <span><a href="../JavaScript30/Day06/index.html">Day06</a></span></h5>
                    <h5>JavaScript 30 : <span><a href="../JavaScript30/Day07/index.html">Day07</a></span></h5>-->
                    
                    <br>

                    

                    
                    
                    </div>
                
            </ol>

        <h4>●Questions●</h4>
            <p>
            </p>

        </section>


    </main>
    <footer>
        Shion Keaty | WDD330
    </footer>


    <script src="../week7/week7.js"></script>
</body>

</html>